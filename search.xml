<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git远程托管平台下配置]]></title>
    <url>%2F2018%2F04%2F18%2Fgit-config%2F</url>
    <content type="text"><![CDATA[1. 不同平台同账号配置1.1. 生成公钥123ssh-keygen -t rsa -C &quot;gana10007@163.com&quot; -f ~/.ssh/coding-rsa#coding-rsa:生成公钥私钥对的文件名称# ~/.ssh/表示生成的路径,windows下指向C:\Users\Administrator,Administrator表示当前的用户名 1.2. 托管平台配置 托管平台有很多,例如:号称全球最大的同性交友平台的github、码市和码云 配置方式大同小异,以github为例: 选择settings,当然英文不好的可以直接使用浏览器的翻译功能(推荐谷歌) 这里就可以看到设置选项 点击New SSH key,将之前生成的coding.net.pub文件中内容全部复制过来 点击新建之后会有标题和公钥内容的选项,标题无所谓 1.3. 配置多个平台托管 在.ssh目录下创建一个名字是config的文件,主要此文件没用后缀名 文件的内容如下 12345678910111213StrictHostKeyChecking no# 为了更简化，把known_hosts也省略掉了UserKnownHostsFile /dev/null# codingHost git.coding.netUser gana10007@163.comPreferredAuthentications publickeyIdentityFile ~/.ssh/coding.net# githubHost github.comUser gana10007@163.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github 如果稍微有点编程基础应该能看的出是啥意思,IdentityFile指向你不同托管平台存放公钥的文件名 具体配置如下图 测试是否能够连接: 1ssh -T git@github.com 注意:@后面跟的内容以平台项目的地址为准,例如码市的: ssh -T git@git.conding.net 2. 同平台下多个账号配置2.1. 具体配置项1234567891011121314StrictHostKeyChecking noUserKnownHostsFile /dev/null # 为了更简化，把known_hosts也省略掉了# githubHost github.com1HostName github.comUser gana10007@163.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github# githubHost github.com2HostName github.comUser yanjianjie6158@163.comPreferredAuthentications publickeyIdentityFile ~/.ssh/admin-coder163 2.2. 测试是否连通1$ ssh -T git@github.com2 2.3. 设置局部的用户名和邮箱：12git config user.email &quot;one_email&quot;git config user.email &quot;two_email&quot; 2.4. 添加remote1234#删除原来的git remote rm origin#添加新的$ git remote add origin git@github.com2:489405826/coinbigapi.wiki.git 以上配置完成就可以正常拉去和推送]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[websocket-初探]]></title>
    <url>%2F2018%2F04%2F18%2Fwebsocket-%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[1. 软件环境 Eclipse版本：Version: Mars.2 Release (4.5.2) SpringBoot：2.0.0.RELEASE JDK：1.8.0_151_64位 2. 配置文件 SpringBoot配置：application.properties 1application.properties SpringBoot配置：application.properties 123server.port=8080logging.level.org.springframework=infologging.level.root=info 核心依赖：pom.xml 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 日志配置：logback-spring.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;configuration&gt; &lt;!--定义一个带颜色的控制台输出日志PATTERN--&gt; &lt;property name="CONSOLE_LOG_PATTERN" value="时间:%date&#123;yyyy-MM-dd HH:mm:ss&#125; 级别: %blue(%-5level) 进程: %magenta(%thread) 类: %green(%logger) 信息: %msg%n"/&gt; &lt;!--定义一个不带颜色的文件日志输出格式,因为文件不能带颜色--&gt; &lt;property name="ERRINFOFILE_LOG_PATTERN" value="时间:%date&#123;yyyy-MM-dd HH:mm:ss&#125; 级别: %-5level 进程: %thread 类: %logger 信息: %msg%n"/&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt; $&#123;CONSOLE_LOG_PATTERN&#125; &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="consoleLog" /&gt; &lt;/root&gt;&lt;/configuration&gt; 3. 服务器端 websocket核心类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.example.demo.websocket;import java.util.concurrent.CopyOnWriteArraySet;import javax.websocket.OnClose;import javax.websocket.OnError;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;/** * WebSocket主要的消息类 * @author 侯叶飞 */@ServerEndpoint(value = "/api/websocket")@Component@Slf4jpublic class WebSocket &#123; /*每个浏览器连接都会有一个新的会话对象*/ private Session session; /*用来存储每个会话的session,静态的不会被实例化*/ private static CopyOnWriteArraySet&lt;WebSocket&gt; webSocketSets = new CopyOnWriteArraySet&lt;&gt;(); @OnOpen public void onOpen(Session session) &#123; this.session = session; webSocketSets.add(this); log.info("【websocket消息】有新的连接, 总数:&#123;&#125;", webSocketSets.size()); &#125; @OnClose public void onClose() &#123; webSocketSets.remove(this); log.info("【websocket消息】连接断开, 总数:&#123;&#125;", webSocketSets.size()); &#125; @OnError public void onError(Throwable e, Session session) &#123; webSocketSets.remove(this); log.info("【websocket消息】连接出错或未关闭socket：" + e.getMessage()); &#125; @OnMessage public void onMessage(String message, Session session) &#123; log.info("【websocket消息】收到客户端发来的消息:&#123;&#125;", message); &#125; public void radioMessage(String message)&#123; for(WebSocket ws:webSocketSets)&#123; ws.session.getAsyncRemote().sendText("广播："+message); &#125; &#125;&#125; websocket配置类 1234567891011121314151617package com.example.demo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * WebSocket Tomcat的配置,如果是war包这个需要去掉 * @author 侯叶飞 */@Configurationpublic class WebsocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; SpringBoot启动类 1234567891011121314package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class RedisDemoApplication &#123; public static void main(String[] args) throws InterruptedException &#123; SpringApplication.run(RedisDemoApplication.class, args); &#125;&#125; 4. 客户端 index.html： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;整合示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="javascript:connection('ws://localhost:8080/api/websocket')"&gt;建立连接&lt;/a&gt; &lt;br /&gt; &lt;div id="showMsg"&gt;&lt;/div&gt; &lt;!-- 引入自己的js --&gt; &lt;script type="text/javascript" src="app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; app.js： 12345678910111213141516171819202122232425/* 创建一个方法,用来连接我们的websocket服务 */function connection(url) &#123; if ("WebSocket" in window) &#123; console.log("您的浏览器支持 WebSocket!"); // 打开一个 web socket var ws = new WebSocket(url); console.info(ws.readyState); ws.onmessage = function(evt) &#123; var received_msg = evt.data; console.log("数据已接收..."+received_msg); showMessage(received_msg); &#125;; &#125;else &#123; // 浏览器不支持 WebSocket alert("您的浏览器不支持 WebSocket!"); &#125;&#125;;function showMessage(data) &#123; var div = document.getElementById("showMsg"); div.innerHTML = div.innerHTML + data+"&lt;br /&gt;"&#125;; 备注：完整的JS代码可以参考-菜鸟教程-websocket]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[websocket-初识]]></title>
    <url>%2F2018%2F04%2F18%2Fwebsocket-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. 概念理解1.1. HTTP长连接和短连接 短连接的操作步骤是： 建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接 长连接的操作步骤是： 建立连接——数据传输…（保持连接）…数据传输——关闭连接 长连接和短连接的优点 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。 长连接和短连接的缺点 长连接：存活功能的探测周期太长,随着客户端连接越来越多，server早晚有扛不住的时候 如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 1.2. 轮询 是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息。这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。 2. 消息队列中点对点与发布订阅2.1. 背景知识 JMS一个在 Java标准化组织（JCP）内开发的标准（代号JSR 914）。2001年6月25日，Java消息服务发布JMS 1.0.2b，2002年3月18日Java消息服务发布 1.1.Java消息服务（Java Message Service，JMS）应用程序接口一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。点对点与发布订阅最初是由JMS定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅)2.2. JMS中定义 JMS规范目前支持两种消息模型：点对点（point to point， queue）和发布/订阅（publish/subscribe，topic）。 点对点： 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。这里要注意： 消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。 发布/订阅 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。 总结: queue实现了负载均衡，一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，一个queue可以有很多消费者，他们之间实现了负载均衡，所以Queue实现了一个可靠的负载均衡。 topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝，只有在消息代理收到消息时有一个有效订阅时的订阅者才能得到这个消息的拷贝。 3. WebSocket协议 WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。目前的Web服务绝大部分都是基于HTTP的，因此为了使得WebSocket能够被广泛使用，WebSocket决定使用HTTP来作为初始的握手（handshake）。WebSocket的握手基于HTTP中的协议升级机制，当服务端收到这个HTTP的协议升级请求后，如果支持WebSocket协议则返回HTTP状态码101。 PS：参考资料-知乎 3.1. Websocket连接的创建过程 WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下： 1234567GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13 GET请求的地址不是类似/path/，而是以ws://开头的地址； 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接； Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据； Sec-WebSocket-Version指定了WebSocket的协议版本。 服务器如果接受该请求，就会返回如下响应 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string 101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。 版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些 消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本 3.2. WebSocket的浏览器兼容性问题 目前相当一部分浏览器不支持WebSocket协议，譬如IE浏览器只在IE10或者更高版本支持WebSocket。另外，一些受限的代理也可能会禁止HTTP的协议升级，从而阻碍WebSocket的握手与使用。因此为了协助client与server进行消息格式的协商，WebSocket在握手的时候保留了一个子协议字段。 STOMP是面向文本的消息传送协议。STOMP客户端与支持STOMP协议的消息代理进行通信。STOMP使用不同的命令，如连接，发送，订阅，断开等进行通信 3.3. Spring与STOMP 根据Java WebSocket API规范（JSR-356），Spring 4提供了一个包含在模块spring-websocket和spring-messaging中的解决方案 STOMP中定义了三种消息： SEND：client向server发送消息 SUBSCRIBE：client向server订阅某种类型的消息 MESSAGE：server向client分发消息 Spring的spring-messaging模块支持STOMP协议，包含了消息处理的关键抽象。下面是一个简单的消息处理示意图： 关键实体的作用如下： Message：消息，里面带有header和payload。 MessageHandler：处理client消息的实体。 MessageChannel：解耦消息发送者与消息接收者的实体。举个例子，client可以发送消息到channel，而不用管这条消息最终被谁处理。 Broker：存放消息的中间件，client可以订阅broker中的消息。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>websocket教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DelphiXE10-基本数据类型]]></title>
    <url>%2F2018%2F01%2F26%2Ftutorial-delphi-2%2F</url>
    <content type="text"><![CDATA[枚举类型 Pascal程序不仅用于数值处理，还更广泛地用于处理非数值的数据。例如，性别、月份、星期几、颜色、单位名、学历、职业等。​ 1. 枚举类型的定义 格式: type 枚举类型标识符=(标识符1,标识符2,…,标识符n) 2. 枚举类型特点 枚举元素只能是标识符； 定义枚举类型时列出的所有枚举元素构成了这种枚举类型的值域（取值范围）。例如，下列类型定义是合法的： 123 type days=(sun,mon,tue,wed,thu,fri,sat); colors=(red,yellow,blue,white,black,green); 而下列类型定义是错误的: 123type colortype=('red','yellow','blue','white'); numbers=(1,3,5,7,9); 枚举类型属于顺序类型 根据定义类型时各枚举元素的排列顺序确定它们的序号，且序号从0开始。例如，定义type days=(sun,mon,tue,wed,thu,fri,sat); 则， ord(sun)=0,ord(mon)=1,……，以此类推。枚举类型中的第一个元素无前趋，最后一个元素无后继。pred(sat)=fri; succ(sun)=mon; ord(sat)=6; 同一个枚举元素不能出现在两个或两个以上的枚举类型定义中。如下列定义是错误的: 123type color1=(red,yellow,white); color2=(blue,red,black); // 因为red属于枚举类型color1和 color2 枚举类型变量只能进行赋值运算和关系运算，不能进行算术运算和逻辑运算. 在枚举元素比较时，实际上是对其序号的比较。 例如定义如下： 1234567891011121314type days=(sun,mon,tue,wed,thu,fri,sat); colors=(red,yellow,blue,white,black,green); var color:colors; weekday:days; //则下面语句是合法的: weekday:=mon; if weekday=sun then write('rest'); //而下面语句是不合法的: mon:=1; //错把枚举值当成变量名； weekday:=blue； //枚举值blue不属于枚举变量weekday的值域； read(color); //枚举类型变量 不能用读语句进行赋值； write(weekday); writeln(blue);//不能通过写语句输出枚举类型的变量值和枚举值。 可以把变量的说明与类型的定义合并在一起，如: 123 var holiday,workday:(sun,mon,tue,wed,thu,fri,sat); color:(red,yellow,blue,white,black,green); 对枚举数据的输入与输出可通过间接方式进行。输入时，一般可输入一个代码，通过程序进行转换，输出时，也只是打印出与枚举元素相对应的字符串。这在后面的例题中将有使用示例。 3. 应用实例 例1、输入今天是星期几的序号，输出明天是星期几的英文单词（星期天序号为0）。 1234567891011121314151617181920212223242526 type weekday=(sun,mon,tue,wed,thu,fri,sat); var i : integer; today,tomorrow : weekday; begin writeln('What date is it'); readln(i); case i of &#123; 根据输入转换成枚举型 &#125; 0:today:=sun; 1:today:=mon; 2:today:=tue; 3:today:=wed; 4:today:=thu; 5:today:=fri; 6:today:=sat; end; if (today=sat) then tomorrow:=sun else tomorrow:=succ(today); write('The tomorrow is '); case tomorrow of sun:writeln('sunday'); mon:writeln('monday'); tue:writeln('tuesday'); wed:writeln('wednesay'); thu:writeln('thursday'); fri:writeln('friday'); sat:writeln('saturday'); end; end. PS: 枚举类型是一种有序类型，所以枚举类型的变量可以作为循环变量。 子界类型 如果我们定义一个变量为integer型，那么它的取值范围一般为-32768～32767。而事实上，每个程序中所用的变量的值都有一个确定的范围。 例如，人的年龄一般为1到120岁，一年中的月数为1到12月，一月中的天数为1到31天等等。 如果能在程序中对所用的变量的值域作具体规定，就便于检查出那些不合法的数据，这就能更好地保证程序运行的正确性且在一定程度上节省内存空间。 子界类型能很好解决上面的问题。此外，在数组的定义中，常用到子界类型，以规定数组下标的范围。 1. 定义格式 type 子界类型标识符=常量1..常量2 &gt; 常量1称为子界的下界，常量2称为子界的上界； 注意事项：​ 下界和上界必须是同一顺序类型（该类型称为子界类型的基类型），且上界的序号必须大于下界的序号。例如 type age=1..100; letter=’a’ ..’z’; 可以直接在变量说明中定义子界类型。如：type letter=’a’..’ z ‘; var ch1,ch2:letter; 可以合并成: var ch1,ch2:’a’..’d’; 2. 运算规则 凡可使用基类型的运算规则同样适用该类型的子界类型。 例如，可以使用整型变量的地方，也可以使用以整型为基类型的子界类型数据。 对基类型的运算规则同样适用于该类型的子界类型。例如，div，mod要求参加运算的数据为整, 因而也可以为整型的任何子界类型数据。 基类型相同的不同子界类型数据可以进行混合运算。 例如：设有如下说明： var x:1..100; y:1..500; z:1..1000; a:integer; 则下列语句是合法的： a:=Sqr(x)+y+z; z:=x+y 下列语句: y:=x+z+a; 当x+y+a的值在1～500范围内时是合法的，否则会出错。 3. 应用举例 例1、使用子界型情况语句，当输入月、日、年(10 30 1986)，输出30 Oct 1986。 1234567891011121314151617181920212223242526272829303132333435var month: 1..12; day: 1..31; year: 1900..2003;begin write('Enter date(mm dd yy):'); readln(month, day, year); write(day); case month of 1: write('Jan'); 2: Write('Feb'); 3: write('Mar'); 4: write('Apr'); 5: write('May'); 6: write('Jun'); 7: write('Jul'); 8: write('Aug'); 9: write('Sep'); 10: write('Oct'); 11: write('Nov'); 12: write('Dec'); end; 例2、将一个四位的十六进制数转换成十进制数。 1234567891011121314151617181920212223242526272829303132var ch: char; n: 1..4; d1, d2, d3, d4, t: 0..15; s: real;begin Write('The hex number is '); for n := 1 to 4 do begin &#123; 把四位的十六进制数分四次作为字符读入 &#125; Read(ch); write(ch); &#123; 分别转换为十进制的数d1,d2,d3,d4, &#125; if (ch &gt;= '0') and (ch &lt;= '9') then t := ord(ch) - 48; if (ch &gt;= 'a') and (ch &lt;= 'z') then t := ord(ch) - 87; if (ch &gt;= 'A') and (ch &lt;= 'Z') then t := ord(ch) - 55; case n of 1: di := t; 2: d2 := t; 3: d3 := t; 4: d4 := t; end end; s := d1 * 16 * 16 * 16 + d2 * 16 * 16 + d3 * 16 + d4; writeln('dec:', s)end. 集合类型集合是由具有某些共同特征的元素构成的一个整体。在pascal中，一个集合是由具有同一有序类型的一组数据元素所组成，这一有序类型称为该集合的基类型。。 1. 集合类型的定义和变量的说明 集合类型的一般形式为： set of 基类型; 基类型可以是任意顺序类型, 而不能是实型或其它构造类型。同时，基类型的数据的序号不得超过255。例如下列说明是合法的: 12345678type numbers = set of 0..9; ch = set of char; day = (sun, mon, tue, wed, thu, fri, sat);var s: numbers; c: ch; weekday: day; 可以将类型说明与变量说明合并在一起，如: 123var s:set of 0..9; &#123; 子界型 &#125; c:set of char; weekday: (sun,mon,tue,wed,thu,fri,sat); &#123; 枚举型 &#125; ps 注意：集合的元素个数不超过256个，因此 var s:set of integer; 是错误的。 2. 集合的值 集合的值放在一对方括号中，中间各元素之间用逗号隔开。如：[1,2,5] 和 [‘a’,’e’,’i’] 都是集合。 在集合中可以没有任何元素，这样的集合称为空集。[] 空集 在集合中，如果元素的值是连续的，则可用子界型的表示方法表示。例如： ［1,2,3,4,5, 10,15］ 可以表示成： ［1..5,10,15］ 集合的值与方括号内元素出现的次序无关。例如［1,5,8 ］和［5,1,8］的值相等。 在集合中同一元素的重复出现对集合的值没有影响。例如，［1,8,5,1,8］与［1,5,8］的值相等。 每个元素可用基类型所允许的表达式来表示。如 ［1,1+2,4］、［succ(ch)］ 3. 集合的运算 集合类型变量不能进行算术运算，集合是无序的，不能使用ord、pred、succ等函数。 赋值运算:只能通过赋值语句给集合变量赋值，不能通过读语句赋值，也不能通过写语句直接输出集合变量的值。如：集合变量赋值: c:=[‘2’]; i:=[5]; w:=[];集合变量赋子界值: c:=[‘a’..’z’]; i:=[1..7];集合变量赋枚举值: c:=[‘a’,’b’,’d’,’m’]; i:=[2,4,6,8,10];函数赋值操作：添加一个集合元素 Include(s, 1);删除一个集合元素 Exclude(s, 1); 集合的并、交、差运算可以对集合进行并(＋)、交(＊)、差 (－)三种运算，每种运算只有一个运算符、两个运算对象，运算结果仍为集合。注意它们与算术运算的区别。 并运算 （关系代数运算符∪）A，B为两个集合，由集合A中的元素加上集合B中的与A不重复的所有元素组成的集合，称为集合A和B的并。即A+B，如：[X，Y，Z]+[X] 为 [X，Y，Z] { 两个集合中不重复的所有元素 }[1]+[4] 为[1，4] 交运算 （关系代数运算符∩）A，B为两个集合，由既属于集合A中的元素又属于集合B中的所有元素组成的集合，称为集合A和B的交。即AB，如：[X，Y，Z][X] 为 [X] { 两个集合中的相同元素 }[X，Y，Z]*[M] 为 [] 差运算 （关系代数运算符-）A，B为两个集合，由集合A中的元素除去集合B中与A相同的元素组成的集合，称为集合A和B的差。即AB，如：[X，Y，Z]-[X] 为 [Y，Z ] { 在集合A中又不在集合B中的所有元素 }[X，Y，Z]-[M] 为 [X，Y，Z] 集合的关系运算： 运算结果为布尔值 关系运算符：= 相等、 &lt;&gt; 不相等 &gt;= 包含，表示前者蕴含后者，相当于集合论中的 &lt;= 包含于，表示前者蕴含于后者，相当于集合论中的 。例如：[a,b,c]=[b,c,a] 为true，元素个数相同，内容相同，不管排列顺序如何。[a,b,c]&gt;=[a] 为true；[a,b]&lt;=[a,b,c] 为true。 in运算：in的右边为集合，左边为与集合基类型相同的表达式，为布尔值。in测试一个元素是否在集合中。相当于集合论中的∈。它们都是二目运算，且前４个运算符的运算对象都是相容 的集合类型。例如：a in［b,c］ 为false。 设集合a:=[1..10]； x 为integer，如x在集合a中即删除a中的元素x，否则把元素x添加到集合a中。程序段如下：if x in a then a:=a-[x] else a:=a+[x]]]></content>
      <categories>
        <category>Delphi教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git对象]]></title>
    <url>%2F2018%2F01%2F11%2Fgit_object%2F</url>
    <content type="text"><![CDATA[Git对象 版本控制在于文件的控制，git的控制方法在于为每个文件生成（key,object）的结构。git利用sha-1加密算法，对每一个文件生成一个唯一的字符序列（明文大小不超过2^64位，对于普通文件，这个大小都可以满足）作为hash_key。 init初始化一个本地仓库，打开隐藏目录.git，其内容如下图。可以看到一个objects的目录，里面只有info和pack两个空文件夹。初始化的时候不存在任何object，也就是没有任何文件被记录下来。 在Git系统中有四种类型的对象，几乎所有Git操作都是在这四种Git对象上进行的，所以了解这四种对象的作用对于应用Git有很大帮助。这四种对象是： “blob”：一个“blob”通常用来存储文件的内容。一个“blob”对象就是一块二进制数据，它没有指向任何东西或有任何其它属性，甚至没有文件名。因为“blob”对象内容全部都是数据，所以如若两个文件在一个目录树或是一个版本仓库中有同样的数据内容，那么它们将会共享同一个“blob”对象。“blob”对象和其所对应的文件所在路径、文件名是否改被更改都完全没有关系。 我们在工作目录下添加一个文件readme，里面只要一个字符串”file1 content”，使用git hash-object [文件名]，可以查看其经过算法生成的hash-key.这个一个40个字符长度的序列。 查看object 执行：git add readme 将文件加入到暂存区之后再次查看 查看3d目录下的内容，可以看到40位的hash-key 前两位作为目录名，后38位作为文件名，标识了这个object对象，这个对象里面的内容就是刚才readme里的内容，可以查看这个对象的内容和对象类型： “tree”：像一个目录，管理一些“tree”对象或是“blob”对象。它有一串指向“blob”对象或是其它“tree”对象的指针，一般用来表示内容之间的目录层次关系(就像文件和子目录)。它的树节点信息包含文件名，hash-key，文件类型、权限等等。这样就可以组织整个需要控制文件的结构 工作目录下添加一个目录dir_1，在dir_1添加一个文件1.txt 内容随意 使用git add . 将文件加入暂存区，查看该文件的hash-key git hash-object 查看object文件夹内容 只存在一个6d的目录，也就是b138a对应的1.txt文件，这时我们的目录并没有生成tree对象，tree对象是在commit的过程中生成的,其生成会根据.git目录下的index文件的内容来创建。git add的操作就是将文件的信息保存到index文件中，在commit时，根据index的内容来生成tree对象。 使用git ls-files –stage命令，我们看看index里的类容: 我们进行第一次commit,生成commit对象，同时生成tree对象,master^{tree},表示master分支所指向的tree对象。 目前我们的git仓库的内部结构如下： “commit”：“commit”对象指向一个“tree对象”，并且带有相关的描述信息，标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如时间戳、最近一次提交的作者、指向上次提交的指针等等。 刚才的总体tree图，只包含了四个对象,我们使用git log查看commit的历史 其中的fd对应的文件夹就是我们的commit对象，它指向工作目录tree,和上一次的commit,这是第一个commit ，所以上一个commit不存在。 现在我们在工作加入一个新的目录dir_2,和该目录下文件2.txt 查看对象信息 这个tree包含了当前的文件目录和内容，现在我们的对象完整的图如下： ps:可以看到commit对象指向了工作目录tree，这样只要切换commit,就可以随意切换我们的版本类容 PS：在Git中blob、commit和tree对象的关系看起来会如下图: 命令总结]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git-cygwin]]></title>
    <url>%2F2018%2F01%2F05%2Fgit1%2F</url>
    <content type="text"><![CDATA[下载：https://cygwin.com/install.html 官网下载是setup.exe相当于一个下载器,并不是安装包,Cygwin中模块的安装、卸载都可以通过它来实现 安装1. 双击setup.exe，则会出现安装界面： 可以看到，其中对于setup.exe，即此安装包，也是有对应的版本的，此处的是2.774。 2. 选择Cygwin的安装方式 点击“下一步”，出现“Choose installation type”界面： Install from internet(downloaded files will be kept for feature reuse): 从网上下载（下载下来的文件，也可以将来再用）:其意思是，从网上下载的文件，存在本地硬盘后，以后万一遇到诸如某个模块被破坏了，不能用了，则可以再通过此setup.exe去重新安装一下，但是选择的是下面要说的第三项，即选择从本地某个文件夹安装，即此处之前下载好了的，效果相当于，windows中安装程序的修复功能 Download Without Installing 只下载不安装:其用意，暂时没有完全搞懂。大概是为了先完全下载下来，然后方便选择性的安装自己需要的模块吧。 Install from Local Directory 从本地安装：上面已经提到了，其前提是，之前已经下载过了对应的所需的各个安装模块了，此时可以选择此项，去全新安装或者修复式安装某个模块。 3. 选择Cygwin的安装根目录 点击“下一步”后，出现“Select Root Install Directory”的界面： 其中Root Directory，指的是你所要将Cygwin安装到哪个目录。 默认为C:\cygwin，此处可以改为自己所要的路径，也可以用默认值，都可以。 我此处改为我所要的路径：E:\DevTools\Cygwin\cygwin_install 然后对于Install for，有两种选择： All User(RECOMMENDED)：为windows当前所有用户都有效。 Just Me：只对当前的windows用户有效。 此处选择默认的，对所有用户都有效，即可 4. 选择Cygwin的本地安装包下载路径 点击“下一步”后，进入“Select Local Package Directory”的界面： 其中Local Package Directory部分，是由于前面选择的是从网上下载并安装，所以此处让你选择对于下载下来的各个模块的安装文件，都放在哪里，此处，根据自己需要，设置一个路径即可 设置的路径（文件夹）最好是已经创建好的，不过要注意一点的是，确保你的设置的路径，是真实存在的，否则就会出现这样的错误提示了： 5. 选择网络连接方式 然后就进入”Select Your Internet Connection“的界面了： Direct Connection 一般多数用户都是这种直接连接的网络，所以都是直接使用默认设置即可。 Use Internet Explorer Proxy Settings 使用IE代理设置，如果你本身上网是通过代理上的，且IE中已经设置好了代理，那么就可以用此种设置了。 Use HTTP/FTP Proxy 使用HTTP或FTP类型的代理。同理，如果有需要，自己选择此项后，设置对应的代理地址和端口，即可。 6. 选择（所要连接的）服务器（去用于后续下载文件） 点击”下一步“后，其会自动去下载一个服务器的列表，然后跳转到”Choose A Download Site“的界面： 此处需要选择一个服务器，之后就是从该服务器下载对应的安装所需的模块文件了,此处对于多数人，最好的选择就是选择163的服务器。 在Use URL处，输入：http://mirrors.163.com/cygwin/ 7. 选择需要安装的模块（安装包） 点击“下一步”后，其会解析一下，然后进入”Select Package“的界面： 8. cygwin中如何取消/选择安装单个模块 而想要安装某单个模块，比如gdb模块的话，那么就是对着那个skip前面的图标，点击一下，然后就可以看到gdb模块被选中了，表示安装此模块： 9. Cygwin中如何取消/选择/重新/卸载安装某分类下的所有模块 很明显，如果想要对几十个，几百个模块都想要安装的话，如果都要一个个点击，那岂不是累死了。对此，cygwin早就想好了，给我们提供了更方便的设置，那就是，对于此Devel分类下面的所有的模块，如果你想要都安装，那么可以点击Devel后面的那个Default： 那么Default就会变成Install，同时，其下所有的模块，也都变成选择安装了： 对应的，再次点击Install，则会变成Reinstall，对应的Devel下面的各个模块，也都变成相应的skip了： 此处对于reinstall之所以变成skip，那是因为之前就没有安装过，所以此处对于之前没有安装过的模块，就是变成skip，即也不安装了。而如果你是第二次运行此cygwin安装程序，那么对于那些之前安装过的，则会变成对应的reinstall的。同理，点击Reinstall，则又会变成Uninstall： 8. 关于安装Cygwin模块方面的最简单，最核心的提示 还是那句话，对于新手，很多不清楚各个模块的作用：那么最简单的做法是，全部都选上。当然觉得全部都选上，又太浪费下载时间和安装后的空间的话，那么最为开发用途的cygwin，则至少可以把Base，Devel，Libs，Net，System，Utils等这几个最基本的分类下面的模块都选上。即点击Base，Devel，Libs，Net，System，Utils的Default，使其都变成Install即可： 当然，如果对于这些，你还嫌弃还是太多，那么就只选择Devel，也基本够你日常开发所用了。 PS:特别提示,尽量不要尝试安装所有模块,我自己装了一次占用将近70G的空间,装完又卸了，没什么卵用]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DelphiXE10安装和破解]]></title>
    <url>%2F2017%2F12%2F07%2Ftutorial-delphi-1%2F</url>
    <content type="text"><![CDATA[配套视频地址 链接: https://pan.baidu.com/s/1miqKllQ 密码:gdia 安装包和破解文件下载 链接: https://pan.baidu.com/s/1jI5GAqU 密码:f1km]]></content>
      <categories>
        <category>Delphi教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[程序员这样优化简历，一投制胜]]></title>
    <url>%2F2017%2F12%2F01%2Fzatan-2%2F</url>
    <content type="text"><![CDATA[《花千骨》一剧，白子画为什么收花千骨为徒？ 《琅琊榜》中，梅长苏为什么选靖王而弃太子、誉王？ 《泰坦尼克号》里，杰克和露丝为什么会一见钟情？ 王子基特为什么会选择灰姑娘辛德瑞拉？ 这些问题乍一看似乎和程序员找工作没什么关系，其实，里面的道理都是通的。你想想，为什么你投十份简历，只有一两家公司约你？又或者为什么你每投一份简历都能获得面试机会？ 最根本的原因，就是一方在汲汲渴求，而恰恰另一方呈现出的关键点让其怦然心动。求者心中有所想，而应者恰恰展现了求者所想的那一面。这就是个中奥妙。 程序员在找工作时，在一开始有三件事情会对能否获得面试机会至关重要： 1.知识、技能、经历梳理2.确立求职目标3.简历优化 友情提示：假如你不想看万字长文，可以：跳到第3部分，看简历优化实操；跳到第4部分，看如何提高简历投递成功率。 知识、技能、经历梳理知识、技能、经历，这都是一个人能体现出来的商业价值。一家企业招募某个人，一定是因为这个人可以帮助企业在某方面实现价值。而且，正常情况下，个人的贡献一定要大于企业为这个人负担的各种成本（薪水、社保、公积金、个税等），否则，要你毛用啊。 所以呢，作为程序员，我们一定要清楚自己的价值在哪里。个人的商业价值，可以通过下面五大要素分析出来： 知识 技能 经历 天赋 人脉 我们在招聘网站上填写简历时，内容最多的就是前三个要素。 招聘网站的简历模板大部分根据知识、技能、教育经历、工作经历、项目经历几部分来设计，一路填下来就OK了，然后大家的简历看起来就比较模式化，然后千人一面，然后…… 扯远了，回到知识、技能、经历梳理上来。 在最开始的时候，不建议直接到招聘网站上填写简历。 强烈建议先用word或MarkdownPad来整理记录你认为你具备的所有有价值的知识、技能、经历，不论大小，统统记录下来。这是我们后续优化简历的基础，也是确立求职目标的基础。 知识与技能有必要说一下知识和技能的区别，这是很多人常常混淆的。 知识可以通过语言文字、语音、视频等进行传授，比如像C++、Java、数学、物理、Qt、Android、设计模式、网络协议等都是知识。 技能是对知识和经验的应用能力。比如使用Qt开发桌面客户端软件就是一种技能，使用Java和Android界面类库开发App也是一种技能。 技能的定义多种多样，摘几个来看看吧。 《心理学大辞典》把技能定义为：“个体运用已有的知识经验，通过练习而形成的智力活动方式和肢体动作方式的复杂系统” 百度百科的解释是：掌握并能运用专门技术的能力。 皮连生的定义：技能是在练习的基础上按某种规则或操作程序顺利完成某种智慧任务或身体协调任务的能力。 有了上面的知识和技能的概念，就比较容易搞明白知识与技能的区别和联系了。我的知识大概有这些： C、C++、Java、Scala、Python、Qt、MFC、WTL、QML、Qt Quick、JavaScript、HTML、CSS、Lua、MySQL、MongoDB、XML、Json、Win32 SDK、Node.js、AngularJS、ffmpeg、VLC、DirectShow、Android、Objective-C、HTTP、P2P、RTMP、RTSP、HLS、P2P、socket、UML、软件开发模型（瀑布、迭代、Scrum等）、项目管理知识、团队管理知识、自媒体运营 知识会淡忘，一段时间不用就扔掉了，所以在你的知识图谱里，一定有一些是你经常使用的，现在最熟悉的，比如我最熟悉的就是C、C++和Qt。 我们需要把自己最熟悉的三种知识标注出来，后面会派上用场。 技能就是对知识的运用，所以一般来讲你有什么知识，就能找到一组技能。比如我可能有下列技能： 使用Qt开发客户端软件 使用Qt开发服务器软件 使用Java开发Android App 使用Node.js开发服务器软件 基于ffmpeg和VLC开发视频播放器 使用DirectShow开发视频播放器 利用常见流媒体协议搭建流媒体服务 使用socket开发网络协议 管理项目，制定项目计划，跟踪计划，控制项目进度 团队管理与激励 博客、微信订阅号等自媒体运营 …… 好啦，现在我们应该对知识和技能比较清楚了，应该能梳理出自己掌握了哪些知识和技能了。值得一提的是，往往在说明技能的同时就列出了知识。 需要特别注意的是，每个人都有很多知识和技能，一定要找出你擅长的2-3种知识，2-3种技能，这将是你求职时的重要参考。人只有使用最擅长的技能去做事情，才能达到最好的效果。 经历知识和技能可以帮助我们创造商业价值，而知识和技能的积累过程本身也是有价值的。积累知识和技能的过程，就是经历。 著名电影《贫民窟的百万富翁》讲述了这样一个故事：在孟买贫民窟长大的少年贾马尔参加一个名叫“谁想成为百万富翁”的节目，过五关斩六将，最终赢得了2000万卢布的大奖和他心爱的姑娘。 这个故事的神奇之处就在于贾马尔回答对了诸如“《darshan do ghanshyam》的词作者”、“1973年的动作电影《囚禁》的主演是谁”、“哪一位板球运动员是本世纪历史得分最多的”、“谁发明了左轮手枪”、“百元美钞上是哪一位美国总统的肖像”之类的问题，而这些问题连博士专家都没把握全中！这与他的身份完全不符，引起了节目主持人的质疑，认定他作弊，趁节目暂停录映，通知了警方以欺诈的罪名逮捕了贫民小子。 为什么贾马尔可以做到？随着问答节目的推进，我们发现，原来，这些问题相关的知识，贾马尔根本没有学习过，而是他独特的贫民窟生活刚好遭遇了这些问题。这就是经历的价值。 程序员的（学习、工作、项目）经历同样具有非常独特的价值，在求职过程中往往会发挥非常重要的作用。比如你做过视频项目，那再找类似做视频的公司就很容易脱颖而出；比如你做过图像处理相关的项目，进入美图秀秀之类的公司就相对容易…… 在回顾项目经历时，关于你自己的那部分，一定要想明白并记录下来，从下面三点来挖掘你的亮点： 你负责的工作内容 用到的知识、技能 你对整个项目的贡献（最好可以量化） 我的两个项目经历如下： 【1.互联网视频卡顿优化】项目描述： 智能机顶盒上的视频聚合客户端，在播放视频时，高峰时段或热点视频，经常卡顿。针对此问题，进行优化，以使能够对用户提供流畅的观看体验业绩： 播放效果大幅度提升，卡顿投诉下降80%。职责： 作为项目经理，负责项目范围界定、进度跟踪与控制 作为系统设计，选择技术方案，设计加速与优化算法，设计系统结构。 作为核心开发人员，负责客户端 http 基础类库的开发和服务端 http server（基于Qt） 的开发。 【2.智能电视机顶盒研发】项目描述： 面向电信运营商和零售市场的互联网电视机顶盒。具有视频导航、搜索、点播、直播、语音搜索、游戏、K歌、资讯、教育等非常丰富的功能。环境： Android 4.0.3系统，全志 A10S芯片方案，Java/C/C++业绩： 组建了智能终端团队，2年开发了两代智能机顶盒产品，6款盒子，产品顺利转型。职责： 开发团队组建与管理 硬件平台选型 软件系统结构设计 项目管理 我没有列出前面所说三点对应的所有内容，个人亮点也没完全写出来，但你的心里一定要清楚，你发挥了什么关键作用，如果有攻克技术难点的经历和明显可以量化的业绩，一定要总结出来，面试时经常会被问到哦。 天赋和人脉其实也是个人非常重要的商业价值。天赋的话，一般程序员的简历中很难体现出来，你说你姚明那么高，你说你像白子画那么帅，你说你颜值超过李易峰，对你想去的企业来讲，可能真没太大价值，还不如你想办法表明你学习能力、钻研能力特强，超越一般人儿。 人脉吗，也很难说。假如你用ThinkPhp，认识其创建者刘晨，而目标公司也使用PHP，那估计有用。假如你做iOS开发，你说你和唐巧是哥们儿，也可能有用。这些东西，我觉得在程序员的面试中谈到概率会比简历中出现的概率大。 确立求职目标前戏太长，可能有的朋友已经失去耐性了。别急，高潮马上来临…… 不管是从大学走向社会的初次求职，还是在职场摸爬滚打了N年的老鸟，找工作时都要忌讳一点：茫无目的，漫天撒网。 求职时，明确目标行业、企业、职位，有针对性的做准备，事半功倍。 职业延续性跳一次槽换一个行业，跳一次槽换一门开发语言，这样极其不利于程序员的商业价值积累（知识、技能、业务等）。假如你不是第一次求职，就有必要考虑职业延续性。 假如你现在在金融行业，那换工作时，最好还在里面。这样你的行业相关的经验就可以积累下来，慢慢形成优势。假如你现在做iOS开发，最好换工作时还找iOS相关的，这样你的Objective-C啊，Swift啊、Cocoa啊才能持续精进。…… 当然，如果你发现你不喜欢现在的行业，也不喜欢现在所用的技术，那也没关系，下面的方法可以帮你找到新的兴趣点。一旦你找到新的方向，转换过去之后，同样要考虑以后的延续性哦。每次都说自己不喜欢现在的，更喜欢另一个，这样捣腾几年之后，你很可能会发现，那些闷生不响持续深耕的小伙伴们居然一夜之间都牛逼闪闪起来了…… 成就事件挖掘职业兴趣在我们总结整理自己的工作、项目经历时，要特别留意那些让你特别有成就感的事件，它里面隐藏你的职业兴趣，可以挖掘出你今后乐意从事的职业方向。 我们可以遵循STAR原则来回顾成就事件： S（Situation），背景情况，包括面临的障碍、限制或困难 T（Task），任务，目标，想完成的事情 A（Action），行动计划与步骤，如何克服障碍、达成目标 R（Result），对结果的描述，重点关注你取得了什么成就 一旦有成就事件，就可以继续挖掘。知道High，还是知道因为什么而High，用了什么东西才这么High。可以按照下面两点来分析： 哪一个具体的点让你特别有成就感，比如“达成结果受到领导表彰”、“独立克服某个技术难题”、“用自己的XXX帮到了某某某”、“成功组织大家齐心协力达到目标”…… 用到了什么知识、技能 通过这样的分析，你就可能找到自己的最佳技能和工作中最在意的点在哪里，而有了这些，就可以根据他们来确立新的职业目标。 简历优化假如你不知道自己有什么商业价值、不知道软件开发工程师是否适合自己、不知道想到什么样的行业什么样的企业里什么样的岗位上工作，那我们铺垫了那么长时间的前戏就白费劲了…… 我相信你要接着往下看，一定是心有所属情有所钟，很想真刀实枪来个痛快的。OK，闲言少叙，咱们这就切入正题了。 简历优化分这么几个要点： 聚焦行业、企业、职业 分析招聘信息，提取知识、技能、职责当中的关键词 根据招聘信息里的关键词，筛选个人知识、技能、经历 将匹配到的知识、技能、经历重新组织、呈现 聚焦行业、企业、职业聚焦的目的是缩小目标范围，节省时间和精力，深入研究分析，有针对性的对自己的商业价值进行优化组合，提高简历的吸引力，最后提升获取面试机会的概率。 程序员运用编程语言、技术框架、设计模式、算法等开发针对某个领域问题的软件，软件必然和目标需求和业务密不可分，所以，程序员左手技术，右手业务，假如你对业务内容完全不感兴趣，很难想象你可以把软件做好。因此，当你有了目标产业，目标公司，还要去了解这家公司做什么产品，是产品导向的公司，还是项目导向，还是外包为主，选择那家你对它的业务范围感兴趣的公司，不感兴趣的就果断筛掉。 还是拿我自己为例，我之前有5、6年在消费电子领域工作，开发智能机顶盒软件，涉及视频点播、视频直播，对流媒体有一些研究。最近一年在互联网这块创业。基于延续性的考量，以往工作过的行业领域都需要认真对待，但不一定非要继续在之前的方向上做，换一换也可以。 有的人比较随意，不太珍惜积累，比如看见这家企业HR比较漂亮，就可能一时心血来潮就不管不顾，换行业换技术都在所不惜，总之死活都要去。我呢也比较随意，不过不是因为漂亮的HR或前台，而是生来如此，后天又有意刻意的修炼，导致现在有点儿随遇而安没什么追求。所以，关于行业，我本身其实不太考虑……但有一个基本的原则，不希望进入夕阳产业，也不希望进入走下坡路的企业。 就技术方面来讲，我最擅长的语言是C++，最擅长的框架是Qt（出过《Qt on Android核心编程》和《Qt Quick核心编程》两本书），最擅长的是客户端软件开发。新的职位最好能用上我擅长的知识与技能。 不过，也不是所有人都想一直沿着一条技术栈走下去，我知道有一个哥们儿，用了10年C#，实在腻歪透了，在原公司不能转到其它方向，就跳了出来，想换到C++相关的技术栈上，结果总是有公司希望他从事能用到C#的岗位，不断给他打电话，他每次都拒绝掉。 啰里啰嗦那么多，我现在锁定的目标是高级软件开发工程师，语言是C++。行业领域的话，互联网、智慧城市、云服务等都可以。还有，我之前都在小公司摸爬滚打，现在希望到比较大一点的公司里体验一下不同的工作氛围。嗯，这是基本诉求了。 如果找软件开发工作，我现在有两个不好的点： 最近一年没做什么开发工作，会被人质疑廉颇老矣尚能饭否 最近几年都在做技术管理工作，别人可能会奇怪你为什么倒回去做开发 不过，换个角度想想，其实也没什么，我做过管理创过业，再回来做开发不是更稳定嘛。 好啦，我的聚焦过程已经完成了，接下来咱们进入简历优化的实操过程。 简历优化实操程序员的简历，一般包含下列内容： 基本资料（姓名、性别、年龄、婚否、电话、当前在职状态） 求职意向（职位、工作地点） 知识、技能 自我评价 教育经历 工作经历 项目经验 附加信息（比如兴趣爱好、荣誉、博客、开源项目等） 根据实际情况，有的简历可能没有自我评价、附加信息，有的可能没有可写的教育经历（比如高中生），有的可能没有工作经历和项目经验（如大学生等初次求职者）。 特别提一下程序员的一些个人品牌相关的附加信息，比如技术博客、github主页、参与的开源项目、自己做的App等，都是能非常好展现程序员知识、技能的东西，能为你的简历加分，也能弥补面试时间短信息交流补充分的问题。要知道，决定你能否通过简历关的，通常是另外一个程序员，而对聪慧内敛的程序员致敬的最好方式，就是“Show me the code”。 简历模板很多程序员都使用招聘网站提供的简历模板，要在不同招聘网站上发布简历的话，可能要重复填写5、6次简历，非常耗时。不过这也是没办法的事情，各家平台不统一数据交换格式，只好麻烦求职者了。我一般会有一份基础的word格式的简历，根据它在不同的招聘网站创建不同的简历。 接下来介绍我的简历，非常简单，顺次包括下列五部分内容： 个人信息 求职意向 技能与评价 工作经历 项目经验 我简历的前三部分简单如下： 个人信息 男，xxxx年xx月xx日生于xxx地方 2002年毕业于西安交通大学，电子信息工程专业，学士学位 153xxxxxxxx, foruok@163.com 已婚求职意向 高级软件开发工程师，西安技能与评价 7年部门管理经验，丰富的项目、团队管理经验 7年嵌入式开发经验，在互联网电视机顶盒、车载娱乐系统、手持娱乐设备（MP3/MP4）等领域有成功经验 丰富的软件系统架构设计经验 熟悉常见的设计模式，有丰富的面向对象设计经验 精通C/C++，熟悉Java，Shell，了解python，Lua，JavaScript等 可熟练在Android、嵌入式Linux、Windows CE、Windows、Linux等平台下进行开发 熟悉Android/Qt(E)/MFC/WTL等GUI框架 熟悉DirectShow/GStreamer/MPlayer/FFMPEG/VLC/Vitamio等多媒体框架 熟悉网络编程，熟悉各种流媒体协议（http/HLS/rtmp/p2p/rtsp等） 博客：http://blog.csdn.net/foruok github：https://github.com/foruok 公众号：程序视界 著有《Qt on Android核心编程》和《Qt Quick核心编程》 我工作年限长，工作经历与项目经历有很多，逐一列举有堆砌字数之嫌，前面已经列出了两个项目经历这里不再重复，下面列最近的几段工作经历： 工作经历2014.12~2015.12，陕西XX网络科技有限公司职位：技术总监职责：团队组建、管理、技术方向把握、项目管理、产品管理业绩：3个月组建10人团队2014.11~2014.12，北京XX商务通信服务有限公司（西安）职位：平台组高级软件开发工程师职责：跨平台软件开发业绩：解决了Qt在Android和iOS两个平台与原生UI叠加的问题2008.01~2014.09，西安XX软件科技有限公司职位：CMC部门经理职责： 1). 部门员工组织、领导、管理、激励，绩效考评 2). 项目计划、实施、跟踪、管理 3). 技术路线评估与选择 4). 系统分析与设计 5). 关键模块代码实现业绩： 1). 2009年至2010年，负责组建机顶盒开发团队与互联网视频搜索开发团队，并带领团队，完成了技术积累和产品探索，使得公司成功进入新的行业领域，完成公司的业务转型 2). 2012—2013年，负责组建智能机顶盒团队，完成机顶盒产品智能化转型 3). 2012.07—至今，主持智能机顶盒产品研发 4). 2011.10—2012.06，主持第二代高清互联网机顶盒产品研发 5). 2009.05—2012.01，负责第一代高清互联网机顶盒产品研发与改进 好了，我简历的主体框架就是这样子了。接下来，我会根据我的目标职位——高级软件开发工程师——来找几条招聘信息，通过分析招聘信息来优化简历的技能与评价、项目经历两个部分。这两部分也是我们优化简历时的重点。 简历优化我拟定过很多次软件开发工程师的招聘需求，技术方面涵盖C++、Java、Android、Web前端等，每次我心里都会浮出一些关键词，这些关键词会进入招聘信息。 反过来，当我去应聘时，我也总希望能从招聘信息里反推出拟定招聘需求的那个软件工程师或项目经理或部门经理心中的关键词，大多数时候是可以的。当你找到了这些关键词，你的简历，就成功了一半。 接下来我们就挑几个招聘需求来看看。 第一个招聘需求如下图所示： 红线标注出来的，是一些关键的基本要求，C++、Qt、Windows桌面客户端，这些是硬性要求，要应聘该岗位必须要满足。 绿线标注出来的，是软性要求，不太容易直接量化和衡量，但面试官可能会在面试中通过交谈来考察。比如软件设计能力、技术传播能力、沟通能力、沟通与团队协作等，通常都是在面试中体现，而编码能力，则可能会通过笔试或者面试中不断的询问技术细节来检验。 蓝线标注出来的，是优选条件，在有多个候选人的情形下，你具备了这些要素，就会被有限考虑。 一般的企业处理软件开发工程师的简历，是HR先挑，然后是技术人员（程序员或经理）再次筛选，通过技术人员的筛选后，就会通知笔试或者面试。 HR一般不大懂技术的东西，他们拿到招聘需求，会和技术人员沟通要关注的关键点，然后根据这些关键点挑选合适的简历。通常在HR眼里，关键点就是关键词，所以，我们修改简历时，尽可能使用招聘信息里出现的字眼，便于HR识别。HR看一份简历，多则一分钟，少则20、30秒。 技术人员筛选简历，通常比HR要细一些，大致分两步，先筛关键词，然后是看项目经验里是否体现出了他们发布的岗位需要的技能和软实力。 关键词匹配不上，PASS，30秒不到；能匹配上，继续看项目经验，整个过程可能会持续几分钟。 在看项目经验时，一方面看应聘者在项目中是否用到了将来需要的相关技能，另一方面看具体项目内容，做行业、产品、业务相关性比对，如果应聘者做的产品与招聘方要做的相关性高，就会被优先考虑。 通过对简历筛选流程的了解，可以知道关键词的重要性了。那接下来我们就要依据从招聘信息中提取的关键点来修改简历了。 在修改简历时，我的做法是尽可能多的在简历中体现企业要求的技能及软实力。一般可以在下面两处反复琢磨： 技能与评价 项目经历 结合我的简历，先看技能与评价部分怎么修改。 因为目标职位是高级软件开发工程师，招聘信息也没有特别体现对管理能力和经验的要求，所以我的管理经验可以淡化或拿掉。然后是突出C++、Qt、软件设计、技术传播等内容。新的版本如下： 技能与评价 9年C++开发经验，精通C++，熟悉STL 5年Qt开发经验，基于Qt开发过8个商业项目，代码超过30万行 著有《Qt on Android核心编程》和《Qt Quick核心编程》 熟悉面向对象编程 熟悉GoF设计模式 丰富的软件设计、软件架构经验 熟悉MFC，熟悉网络编程，熟悉多媒体及各种流媒体协议 热衷技术传播，推动了Qt在团队和公司内的普及 好啦，和之前的版本比较一下，现在的内容，，是不是已经有很大不同了？调整之后，已经兼顾了硬性要求、软性要求和优选条件。 接下来，我们就要重新组织、呈现项目经历，让它更多地体现企业HR、面试官所关注的关键点。下面是我的一个具体的项目经验： 2009.05—2011.09，跨平台视频点播系统项目描述：面向电信运营商和零售市场的综合性视频服务产品，具有视频导航、搜索、点播、直播、天气、资讯、股票、教育等功能。产品形态有机顶盒、Windows客户端、Linux客户端等。软件环境：Embedded Linux，Qt Embedded 4.5.1，Qt 4.5.1，C/C++ 硬件环境：全志 F20芯片方案、PC角色：项目经理、核心程序员职责与工作内容： 1).软件系统结构设计 2).基于Qt GraphicsView框架设计实现十字菜单、影视信息墙 3).基于Qt的客户端业务流程代码实现 4).基于Qt实现认证模块 5).团队组建与项目管理业绩： 1).开发了稳定、性价比高的互联网机顶盒产品，打开了电信市场，销量超过30万台。 2).在团队里推广Qt，形成了技术积累 3).提供Windows及Linux客户端，为客服、运维、售后提供了强有力的支撑 这个招聘需求，和我的匹配点主要在技能（C++、Qt），接下来这个，则主要匹配的是业务（行业）经验。 红线标注出了基本要求：C/C++、Linux。 绿线标注的软性要求，一部分是不太容易量化的技能，比如精通多线程、独立设计经验等，一部分是产品业务相关的，比如音视频编解码、封装、流媒体、网络协议、视频业务系统等。 这则招聘信息中有两个优选条件，不过和我的知识、技能都不匹配。 看一个程序员的知识、技能、经历和看山类似，横看成岭侧成峰，远近高低各不同。要想提高与招聘信息的匹配度，就要想办法从不同的角度挖掘、呈现，这样看着不合适，那样看着就可能刚刚好。所以，如何选取角度就变得很重要。 一个程序员的知识、技能、经历，横看成岭侧成峰，角度很重要。 来看看新修改的技能与评价： 技能与评价 9年C++开发经验，精通C++，熟悉STL 可熟练在Linux、嵌入式Linux、Windows等平台下进行开发 熟悉常见的设计模式，有丰富的独立设计经验 6年视频业务开发经验，设计、开发过点播、直播流媒体处理系统，熟悉FFMPEG、GStreamer等开源框架 精通网络通信，自己实现过标准协议http协议和私有p2p协议，熟悉http/HLS/rtmp/p2p/rtsp等各种流媒体协议 热爱技术，著有《Qt on Android核心编程》和《Qt Quick核心编程》 和面向上一个招聘信息的内容又有了较大差异，是不是？ 这次我改两个项目经历，都是之前改过的，方便比较不同。第一个 2009.05~2011.09，跨平台视频点播系统项目描述：（略）。软件环境：Embedded Linux，Qt Embedded 4.5.1，Qt 4.5.1，C/C++ 硬件环境：全志 F20芯片方案、PC角色：项目经理、核心程序员职责与工作内容： 1).软件系统结构设计 2).独立设计基于Qt的EPG框架 3).设计实现音视频解码、解封装流程（参考ffmpeg） 4).设计实现机顶盒软件的多线程模型 5).团队组建与项目管理业绩： 1).定制的多媒体框架保障了互联网机顶盒产品的视频处理效果，打开了电信市场，销量超过30万台。 2).提供Linux、Windows版本客户端，为客服、运维、售后提供了强有力的支撑 2).坚持自主实现关键的多媒体模块，形成了技术积累 这次我将重点放在了多媒体、设计等方面，与前面那份有了很大不同。 再来看文章最前面提到过的一个互联网视频卡顿的项目经验，新版本如下： 2013.11~2014.06，互联网视频卡顿优化项目描述： 智能机顶盒上的视频聚合客户端，在播放视频时，高峰时段或热点视频，经常卡顿。针对此问题，进行优化，以使能够对用户提供流畅的观看体验职责与工作内容： 1).作为系统设计，选择技术方案，设计加速与优化算法，设计系统结构。 2).C++实现标准http协议（含客户端和服务端） 业绩： 播放效果大幅度提升，卡顿投诉下降80%。 嗯，我觉得已经改出不一样的效果了。 需要特别提醒的是，简历优化是针对程序员知识、技能、经历进行的穿衣打扮，是从不同的视角呈现不同的侧面，可以用心琢磨，但万万不可造假。 检验优化效果如果你确定了求职目标，也能有针对性的优化简历，但对结果比较忐忑，不知道自己优化得怎么样是否能不能打动HR的芳心，这里有一个方法可以试（别说我告诉你的）： 将你钟意的企业和职位分为A、B、C三类，A是最符合你目标的，B与你最核心的诉求匹配，C类呢可能抵触了你的某些核心价值观 针对C类公司的职位，测试你的简历优化技能，找三五家来练手，投递简历，简历过了就去面试，攒面试经验。 C类之后进行B类，最后是A类。 这样的过程，能保证你先练简历和面试技术，然后以最好的状态走向你最心仪的公司最钟意的职位。 如何提高简历投递成功率根据前面的分析，要想提高简历投递的成功概率，遵循下面的流程将非常有帮助： 梳理知识、技能、经历并记录在案，形成基础简历 确立求职目标 筛选招聘信息，选择匹配自己目标的公司和职位 针对每个招聘信息进行分析，提取关键词 根据关键词，结合基础简历，优化技能描述和项目经验，生成一份有针对性的简历 根据我自己的经验，一天可能只能完成3份左右的简历投递。因为，针对每一个职位生成一份有针对性的简历，可能会花费1到2个小时时间，有时甚至更长。不过，花再多的时间都是值得的，因为这种优化将大大提高你简历通过的概率]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[培训机构毕业的程序员被歧视的背后逻辑]]></title>
    <url>%2F2017%2F12%2F01%2Fzatan-1%2F</url>
    <content type="text"><![CDATA[现在，像达内、华清远见、国嵌、北大青鸟、传播智客等等IT培训机构很多，为尚未毕业的大学生、毕业了一时找不到工作的大学生、工作后想转行的再就业者提供了一个掌握新技能的机会，通过三个月或半年或更久的培训，你就可以掌握某一种技能，比如Android开发、Java Web开发、iOS开发、嵌入式Linux开发，然后，没然后了吗…… Sorry，然后还是有的，只不过，“然后”并不是像培训机构的销售代表频频给你通电话时宣传的那样光明罢了。有的机构会推荐你就业直到你彻底失望他们推荐的单位，有的机构会放你出去闯荡江湖四处碰壁……形式不一，但，一段痛苦的旅程从此开始了，这倒是真的。 很多单位歧视培训机构毕业的学员，你所在的单位是这样吗？或者你从IT培训机构毕业后，找工作时被鄙视了吗？ 为了弄明白为什么IT培训机构出来的程序员在找工作时经常遭遇不平等对待，我们需要弄明白“教育”和“培训”的差别。 教育和培训 大致上讲，我们所说的“教育”，指的是掌握一般性的原理与技巧的过程；而我们所说的“培训”，不过是学会某种特定技能的过程。 上面是温伯格在《程序开发心理学》中说到的，符合大多数人对“教育”和“培训”的理解。 你可以通过培训机构学会理发、做饭、修汽车、写代码、做蛋糕，这没什么稀奇的，当我们接受培训时，就是为了某项技能而去的，不是吗？我去蓝翔，难道不是为了开挖掘机吗？ 通常我们认为培训机构（学校）是学习某种不太复杂的谋生技能的摇篮。这种技能还有一个特点，就是相对稳定、变化不是特别频繁，能够在相当长一段时间内保持基本的稳定性。所以，一旦你获得了这项技能，就可以靠它吃饭吃上一阵子，一年半载，三年五年，十年八年，都有可能。 而教育，我们通常认为是一项基础性的工作，重知识，重原理，周期长，见效慢，与社会脱节，有时还能把人变傻（注意我不是讽刺现行教育制度，也不是诋毁我们伟大的大学教育）。虽然如此，很多IT公司的基础部门还是被受过正规大学教育的朋友们占据了重要岗位。因为大家普遍认为，虽然学校教育严重脱离社会现实，但名牌大学的学生的智力水平、学习能力，平均来看还是高于未能考上大学的中学生，更适合于从事某种对智力、学习能力有些特别要求的技术岗位。 没错，程序员正是这样的岗位。程序员的平均智力水平和学习能力高于大部分的其它行业从业者。 然而，教育和培训的差别，并不是关键。关键是，出于某种原因，面试官或公司主管对出身“培训机构”的人有偏见。为了说明这一点，我们先要看看程序员需要的特殊能力。 程序员需要的特殊能力成为一个合格的程序员，需要以下“特殊”能力： 自知之明 自我学习 努力 看起来没什么出奇之处，也许你会觉得一个程序员最重要的能力不是上面三项，没关系，知否知否，应是绿肥红瘦，随便怎么看，横看成岭侧成峰，一千个观众就有一千个哈姆雷特，嗯，开启口水模式……这里省略500字…… 大家公认程序员从事的是烧脑性工作，行业发展日新月异，各种新语言新技术新框架新概念层出不穷，需要程序员时刻保持归零的学习心态，持续不断地保持学习维持竞争能力和价值。所以，我也是从这个角度出发，选择了前面提到的三点，实际上这三点指向的是学习之道。 自知之明我们要了解自己拥有什么、缺乏什么，然后才能开始学习。 通过不断地总结、回顾自己做过的事情，我们就可以慢慢了解自己的能力边界。哪些事情做好了，好在哪里，为什么好在那里而不是别处，是由你自身的哪种行为、才干、能力决定的？哪些事情做得不好，坏在哪里，为什么坏在那个点而不是其它的点，改善你自身的哪种行为或能力可以改变事情的走向，还是说你没什么能改变的那就是你的局限？ 当你了解了自己，就能发现自己应该做什么，就能决定自己的学习方向，而不是盲目地把自己交付给别人（学校、老师、家长、培训机构），因为，没有什么人真的可以为你负责，能为你负责的，只有你自己。 当然，自知是最难的事，也不是一朝一夕的事，需要不断的自省和内视才可以做到。 自我学习知名的教育专家林格有两本非常著名的书，《教育是没有用的》和《学习是不需要教的》。林格有一个非常核心的观点：学习能力是人与生俱来的能力，是人之天赋，是不需要教的，但这种能力会随着年龄的增长和家庭教育、学校教育的误导而萎缩或消失，所以，教育的方向就是营造一个环境，让人自己发现自己的学习能力。 六祖慧能一朝顿悟传承衣钵，佛性自在每人心中。只不过，世人多如神秀，认为“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃”，一定要借助外力和各种各样的清规戒律，方可保持灵台清明，最终获得某种修行。这种扭曲了教育本质的说法、做法大行其道，导致中学教育（大学相对自由）重知识、重规矩、重技能而轻发现、轻唤醒、轻因材施教、轻有教无类，最终扼杀了学生的自我学习能力。所以，很多人不是天生不会学习，而是在成长过程中在家庭、学校、社会的各种外力撕扯中慢慢丧失了自我学习能力。更甚之，多数人不自知这种能力的丧失。 然而，程序员尤其需要自我学习能力。 学校会教你操作系统原理，会教你计算机组成原理，会教你算法，会教你C语言，会教你Java，各种知识都会教你。然而你到工作中，能不能用你学到的知识解决问题，实在是个未知数。 培训机构会教你怎么写Java代码，怎么安装某个IDE，怎么完成一个个人博客或购物车之类的小项目。然而，你是在框好的架子下被动地按照老师的要求“完成”了这些事。到了工作中，面对巨大的未知和陌生的项目，你能不能举一反三灵活运用，充满了未知。 一个程序员能不能自己学会一门技术、能不能自己解决一个问题特别重要。因为，很少有主管会手把手的教会你编程和设计的实际技巧，也很少有主管会大发慈悲把你送去研习班学习工作需要的技能，在一个现实的环境里，一切都要靠你自己。假如你自己不能独立习得某项必须的技术，真没有人能帮得上你。假如你自己不能独立解决问题，真没有人能始终拉扯着你。这也正合梁漱溟说的话：“任何一个人的学问成就，都是出于自学。学校教育不过给学生一个开端，使他更容易自学而已。青年于此，不可不勉。” 很多人轻视培训机构，是认为培训机构的老师，多数脱产，没有丰富的一线工程实践，是业余选手，而这些“业余选手”却要通过短短的一期培训来为社会培养“专业选手”，这基本是一个笑话。即便我们能举出不少从培训机构出来的优秀选手，那也只能说明，这个选手本身具有很好的学习能力。 如果一个人意识到了自己还具备自我学习能力，那他完全没必要去培训机构浪费动辄六七千一两万的学费——他完全可以自己学到必须的知识和技能，假如他真有兴趣的话。 而要检验你是否还有自我学习能力，先不要去培训机构，自己找本讲编程的书、找台电脑、连上网，花一两个月时间就能搞明白你是否适合做一个程序员。一旦你通过了这种自我学习实验，那时再挑一个培训机构系统地学习某条技术栈不迟。 言而总之，你能不能成为合格的或优秀的程序员，取决于自我学习能力，而不是参加过专业培训。所以，很多公司在招募程序员时，不太愿意考虑培训机构毕业的学员，因为在面试官的心里，觉得如果你有能力，自己就可以学会，完全没必要去培训机构，你接受了培训，他反倒认为你可能缺乏自我学习能力（以及对技术的兴趣），担心你不能胜任将来的工作，他太了解了，你学的那点东西根本不够用，还有很多新东西等着你学，所以，他不愿意考虑你。 而对于知名大学的毕业生，虽然可能和你一样是一张白纸，但别人会以为，能进得了大学当得了学霸，起码学习能力没问题的概率高一些。 努力有一句话是这么说的，“以大多数人的努力程度之低，根本还轮不到拼天赋”。其实，努力也是一种天赋。为什么有的人明知努力可以改变生活，可他还是不努力呢？因为，臣妾做不到啊！为什么做不到，因为他缺乏“勤奋”、“努力”之类的天赋和才干。真的，勤奋、努力的人，多数是生就的，少数是被后妈（生活）逼的。 程序员白天要上班，晚上偶尔还要加个班，自由时间少，而新技术很多，什么时候去学呢？你以为实际的项目一定可以让你锻炼新技术吗？要知道，大部分的项目在技术选型时，会考虑技术的成熟度和团队的技术储备，很少有冒险采用大家都不熟悉的技术的，不可控因素太多，风险太大，项目失败的概率很高。那这样的话，你什么时间丰富自己呢？ 八小时之内是现在，八小时之外是将来。你可以用的，就是你的业余时间了。你看，人家都在打游戏、看电视、挎着女伴的胳膊去速8，你还要苦哈哈的学习，如果你没有“努力”这种天赋，是很难做到的。 所以，很多面试官在面对培训机构毕业的人选时，也会有诸如“如果你有自我学习能力并且努力，其实没必要上什么培训班，完全可以自己搞定”之类的想法，而你上了培训班，是不是反过来证明你不够努力咧……然后，他又会想，是不是因为你没自知之明不知道自己要干啥才被忽悠到培训机构去交学费了呢……也许，他还会想，是不是因为你对技术其实不感兴趣只是想谋个事儿干呢…… 额，你看，面无表情之下，其实各种想法如同暗流漩涡，澎湃不息……所以，最后，你可能就只好“回去等消息”了…… 不知道说了这么多，你是否明白了个中原因——面试官会觉得培训出来的学员，可能对技术没有那么浓厚的兴趣、缺乏足够强的自我学习能力也不能很好的自律和努力。但在我的观念里，其实应该这么看待IT培训机构的学员：他只是找了一个类似学校的地方系统学了一些东西，和别人并无什么不同，如果他对技术有兴趣，有自我学习能力，一样可以做一个优秀的程序员。]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Maven高级-搭建私服(Nexus)]]></title>
    <url>%2F2017%2F11%2F23%2Fmaven03%2F</url>
    <content type="text"><![CDATA[安装 访问 配置maven镜像 将配置好的文件复制一份到默认目录中 配置成功的标志 更新nexus的索引 将nexus的服务停止 替换索引文件 添加nexus的远程代理仓库 开源中国社区：http://maven.oschina.net/content/groups/public/ 阿里云：http://maven.aliyun.com/nexus/content/groups/public 点击保存之后刷新浏览器 发布项目 Nexus中仓库的类型 宿主仓库：一般我们发布的项目全部搞到这里 代理仓库：osichina，一般情况下备用仓库 虚拟机仓库：为了兼容以前的版本而保留的仓库,但是现在基本废弃了 仓库组：可以包含多种仓库 发布的版本 一般情况下版本发布：junit4.10.1 &lt; 主版本 &gt; —— &lt; 次版本 &gt; —— &lt; 增量版本 &gt; —— &lt; 里程碑版本 &gt; Maven版本的划分 快照版：Snapshot版本代表不稳定、尚处于开发中的版本 发布版：Release版本则代表稳定的版本 在nexus中发布项目 创建宿主仓库 创建一个可以使用本仓库的用户 创建角色 给角色赋值权限 角色绑定权限 角色绑定账号 在全局配置文件中配置发布项目的账号：C:\Users\Administrator.m2\settings.xml 远程发布的指令：deploy]]></content>
      <categories>
        <category>Maven教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Maven基础]]></title>
    <url>%2F2017%2F11%2F23%2Fmaven01%2F</url>
    <content type="text"><![CDATA[概述 Maven是什么 Maven是一个优秀的项目构建工具 Maven提供了契约式的开发 为什么使用Maven 它可以方便将整个项目划分不同模块,模块和模块之间是有一定联系，具有依赖、聚合…等特点 它为我们的jar文件提供一个统一的仓库,极大的方便我们对Jar依赖的引入 Maven的目录结构 安装 因为maven本身就是开源,所以官方提供了免安装的压缩包 下载地址：http://maven.apache.org/download.cgi 解压官方的压缩包 Maven3.3.x要求JDK版本必须是1.7及以上版本 注意解压路径中不要出现中文 配置环境变量(不是必须的) 步骤略.. 出现以下提示表示配置成功注意事项 JDK的环境变量必须是JAVA_HOM的形式配置如果需要在任意目录下使用maven的话,那么需要配置maven的环境 M2_HOME=D:\apache-maven-3.3.9 PATH=%M2_HOME%\bin 仓库Maven依赖的一个搜索平台 地址：http://mvnrepository.com/ 更改本地仓库的存储位置 默认情况下本地仓库的位置：C:\Users\Administrator.m2\repository 一般情况下不用该目录作为仓库目录,重装系统之后该目录不存在 修改步骤 找到setting.xml文件：在maven_home\conf\settings.xml 具体的更改项：1234567 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;D:\\Maven-Repository&lt;/localRepository&gt; 将更改后的setting.xml文件复制一份到默认的仓库目录中,该步骤不是必须的！有的工具默认读取的位置： C:\Users\Administrator.m2\settings.xml 更改仓库源(其实就是其他大公司搭建的私有服务器,私服搭建笔记参考下面)12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; Maven版的HelloWorld 编写主程序：src/main/java/coder163/HelloWorld.java 1234567package coder163;public class HelloWorld&#123; public void sayHello()&#123; System.out.println("HelloMaven"); &#125;&#125; 编写单元测试类：src/test/java/coder163/Test01.java 12345678910package coder163;import org.junit.Test;public class TestHelloMaven&#123; @Test public void show()&#123; new HelloWorld().sayHello(); &#125;&#125; 编写pom.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;HelloWord001&lt;/groupId&gt; &lt;artifactId&gt;Hello&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;HelloWord001&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 常用指令 mvn compile :编译项目 mvn test :编译项目并且进行单元测试 mvn clean :清除targe目录 mvn package :将项目进行编译、测试、打包 jar\war\pom mvn install :将项目进行编译、测试、打包、发布到仓库中,例如：1mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.1.0 -Dpackaging=jar -Dfile=C:/lib/ojdbc14.jar POM.xml标签解释 注意：maven中把项目名称、模块名称和版本统称为坐标,所有Jar的依赖都需要依靠坐标在仓库中进行查找 &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;：maven的版本信息,固定值.不用管 &lt;groupId&gt; ：项目名称 &lt;groupId&gt;shop&lt;/groupId&gt; &lt;artifactId&gt; ：模块的名称 &lt;artifactId&gt;user&lt;/artifactId&gt; &lt;version&gt; ：项目发布的版本：测试版、快照版本、稳定版、发布版 &lt;packaging&gt; ：项目的打包方式：jar、war、pom &lt;name&gt; ：随意 &lt;url&gt; ：仓库的地址,maven默认情况会先检查本地仓库,如果本地仓库没有所需要的jar,那么会去中央仓库下载 &lt;dependencies&gt; ：依赖,所有的依赖包都需要写在这个标签之内 &lt;dependency&gt; ：具体的依赖 依赖、聚合、继承 依赖：当一个工程依赖于另一工程时,可以将所依赖的工程发布到本地仓库中 在pom.xml中添加依赖的坐标 12345&lt;dependency&gt; &lt;groupId&gt;jsxm&lt;/groupId&gt; &lt;artifactId&gt;jsxm-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 继承：父模块的打包方式必须是POM 12345&lt;dependency&gt; &lt;groupId&gt;jsxm&lt;/groupId&gt; &lt;artifactId&gt;jsxm-user&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 聚合:父模块整合所有的子模块 12345&lt;!--聚合--&gt;&lt;modules&gt; &lt;module&gt;./../jsxm-factory&lt;/module&gt; &lt;module&gt;./../jsxm-user&lt;/module&gt;&lt;/modules&gt; ps:以当前模块的pom.xml为起点查找子模块中的pom.xml的位置 Scope：表示依赖的时期 编译期(compile)：编译的时候会使用,打包也会打进去 测试期(test):测试环境有用,发布时不会打包]]></content>
      <categories>
        <category>Maven教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lucene笔记整理]]></title>
    <url>%2F2017%2F04%2F01%2Flucene01%2F</url>
    <content type="text"><![CDATA[什么是lucene Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个全文检索引擎的架构，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。即： Lucene是根据关健字来搜索的文本搜索工具，只能在某个网站内部搜索文本内容，不能跨网站搜索 Lucene通常用在什么地方 Lucece不能用在互联网搜索（即像百度那样），只能用在网站内部的文本搜索（即只能在CRM，RAX，ERP内部使用），但思想是相通的 Lucene中存的什么内容 lucene中存的就是一系列的二进制压缩文件和一些控制文件，它们位于计算机的硬盘上，这些内容统称为索引库，索引库有二部份组成 原始记录: 存入到索引库中的原始文本 词汇表 按照一定的拆分策略（即分词器）将原始记录中的每个字符拆开后，存入一个供将来搜索的表 为什么网站内部有些地方要用Lucene来索搜，而不全用SQL来搜索 SQL只能针对数据库表搜索，不能直接针对硬盘上的文本搜索 SQL没有相关度排名 查出的结果没有相关度排序，不知道我想要的结果在哪一页。我们在使用百度搜索时，一般不需要翻页，为什么？因为百度做了相关度排序：为每一条结果打一个分数，这条结果越符合搜索条件，得分就越高，叫做相关度得分，结果列表会按照这个分数由高到低排列，所以第1页的结果就是我们最想要的结果。 SQL搜索结果没有关健字高亮显示 SQL需要数据库的支持，数据库本身需要内存开销较大，例如：Oracle SQL搜索有时较慢，尤其是数据库不在本地时，超慢，例如：Oracle 快速上手 书写Lucene的流程 创建索引库: 创建JavaBean对象 创建Docment对象 将JavaBean对象所有的属性值，均放到Document对象中去，属性名可以和JavaBean相同或不同 创建IndexWriter对象 将Document对象通过IndexWriter对象写入索引库中 关闭IndexWriter对象 根据关键字查询索引库中的内容 创建IndexSearcher对象 创建QueryParser对象 创建Query对象来封装关键字 用IndexSearcher对象去索引库中查询符合条件的前100条记录，不足100条记录的以实际为准 获取符合条件的编号 用indexSearcher对象去索引库中查询编号对应的Document对象 将Document对象中的所有属性取出，再封装回JavaBean对象中去，并加入到集合中保存，以备将之用 Maven配置 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;lucene.version&gt;4.0.0&lt;/lucene.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;$&#123;lucene.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt; &lt;version&gt;$&#123;lucene.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://mvnrepository.com/artifact/org.apache.lucene/lucene-analyzers-common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;$&#123;lucene.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://mvnrepository.com/artifact/org.apache.lucene/lucene-memory --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-memory&lt;/artifactId&gt; &lt;version&gt;$&#123;lucene.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- http://mvnrepository.com/artifact/org.apache.lucene/lucene-queryparser --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;$&#123;lucene.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; java代码实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Demo1 &#123; //创建索引库 @Test public void createIndex() throws Exception&#123; //1）创建JavaBean对象 Article article=new Article(1, "培", "积云是专注于培养年薪20W的技术专家"); //2）创建Docment对象 Document document=new Document(); //3）将JavaBean对象所有的属性值，均放到Document对象中去，属性名可以和JavaBean相同或不同 IndexableField idField=new StringField("id", article.getId().toString(), Field.Store.YES); IndexableField titleField=new StringField("title", article.getTitle(), Field.Store.YES); IndexableField contentField=new StringField("content", article.getContent(), Field.Store.YES); document.add(idField); document.add(titleField); document.add(contentField); //4）创建IndexWriter对象 //索引库存放的磁盘路径 Directory dir=FSDirectory.open(Paths.get("D:/luneceDB")); //分词器：标准分词器 Analyzer analyzer= new StandardAnalyzer(); //创建索引库需要的配置 IndexWriterConfig config=new IndexWriterConfig(analyzer); //创建一个索引库 IndexWriter indexWriter=new IndexWriter(dir,config); //5）将Document对象通过IndexWriter对象写入索引库中 indexWriter.addDocument(document); //6）关闭IndexWriter对象 indexWriter.close(); &#125; @Test public void findIndexByKeyWords()throws Exception&#123; String keyWords="20"; //1）创建IndexSearcher对象 Directory dir=FSDirectory.open(Paths.get("D:/luneceDB")); IndexReader reader=DirectoryReader.open(dir); IndexSearcher searcher=new IndexSearcher(reader); //2）创建QueryParser对象 //分词器：标准分词器 Analyzer analyzer= new StandardAnalyzer(); //3）创建Query对象来封装关键字 QueryParser qp = new QueryParser("content", analyzer); Query query = qp.parse(keyWords); //4）用IndexSearcher对象去索引库中查询符合条件的前100条记录，不足100条记录的以实际为准 TopDocs topDocs = searcher.search(query, 100); for(int i=0;i&lt;topDocs.scoreDocs.length;i++)&#123; ScoreDoc scoredoc=topDocs.scoreDocs[i]; Document document = searcher.doc(scoredoc.doc); System.out.println(document.get("id")); System.out.println(document.get("title")); System.out.println(document.get("content")); &#125; &#125;&#125; Lucene常见Field 字段名称 字段描述 IntField 主要对int类型的字段进行存储,需要注意的是如果需要对IntField进行排序使用SortField.Type.INI来比较,如果金范围查询或过滤,需要采用NumericRangeQuery.newIntRange() LongField ,需要 FloatField ,需要 BinaryDocVluesField ,需要 NumericDocValuesField ,需要 SortedDocValuesField ,需要 StringField ,需要 TextField ,需要 StoredField ,需要 关键字封装对象(Query)分词器详解 什么是分词器 采用一种算法，将中英文本中的字符拆分开来，形成词汇，以待用户输入关健字后搜索 为什么要使用lucene中文分词器: 在lucene的开发过程中，我们常会遇到分词时中文识别的问题，lucene提供了lucene-analyzers-common-5.0.0.jar包来支持分词，但多的是对英国，法国，意大利等过语言的支持，因此我们需要引入中文分词的概念 jcseg中文分词器 jcseg是使用Java开发的一款开源的中文分词器, 使用mmseg算法. 分词准确率高达98.4%, 支持中文人名识别, 同义词匹配, 停止词过滤… jcseg支持三种切分模式 简易模式：FMM算法，适合速度要求场合。 复杂模式-MMSEG四种过滤算法，具有较高的岐义去除，分词准确率达到了98.41%。 检测模式：只返回词库中已有的词条，很适合某些应用场合。(1.9.4开始)就分词效率而言，简易模式速度最快 IKAnalyzer(庖丁分词器) IK Analyzer是一个开源的，基亍Java语言开发的轻量级的中文分词工具包。 采用了特有的”正向迭代最细粒度切分算法”，支持细粒度和智能分词两种切分模式； 注意版本兼容，最高支持lucene4.0 查看分词的详细信息 12345678910public void show01()throws Exception &#123; // Analyzer analyzer=new IKAnalyzer(); Analyzer analyzer=new StandardAnalyzer(Version.LUCENE_40); TokenStream tokenStream = analyzer.tokenStream("content",new StringReader("培养年薪20W的IT技术专家")); tokenStream.addAttribute(CharTermAttribute.class); while (tokenStream.incrementToken()) &#123; CharTermAttribute charTermAttribute = tokenStream.getAttribute(CharTermAttribute.class); System.out.println(charTermAttribute.toString()); &#125;&#125; 关键字高亮 POM.xml配置 搜索结果排序条件搜索索引库的管理(CRUD)]]></content>
      <categories>
        <category>lucene教程</category>
      </categories>
  </entry>
</search>
